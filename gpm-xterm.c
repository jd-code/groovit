/*
 * $Id: gpm-xterm.c,v 1.2 2003/03/19 16:45:47 jd Exp $
 * Groovit Copyright (C) 1998,1999 Jean-Daniel PAUGET
 * Copyright 1994,1995   rubini@ipvvis.unipv.it (Alessandro Rubini)
 * Copyright 1994        miguel@roxanne.nuclecu.unam.mx (Miguel de Icaza)
 * 
 * this source is a special adaptation for groovit.
 * you should check for the original version from gpm project.
 *
 * gpm-xterm.c - pseudo client for non-Linux xterm only mouse support.
 *               This code has been extracted from libgpm-0.18 and then
 *               took its own way.
 *
 *  This version has a special hack added by JD (Jean-Daniel PAUGET) 
 *  during summer 1998 for apps to handle arrows w/o problems.
 *  This patch should be included in gpm version to come...
 *
 * Patched version (C) 1998  groovit@disjunkt.com (Jean-Daniel PAUGET)
 * Copyright (C) 1994,1995   rubini@ipvvis.unipv.it (Alessandro Rubini)
 * Copyright (C) 1994        Janne Kukonlehto
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 ********/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>        /* select(); */
#include <sys/time.h>      /* timeval */
#include <sys/types.h>     /* socket() */
/* patch JD 11/08/1998 */
#include <string.h>        /* strncpm (); */

/* JDJDJDJD this is useless (might)
#ifdef HAVE_NCURSES_H
#  include <ncjdurses.h>
#else
#  include <cjdurses.h>
#endif
*/

/* patch JD 14/12/1998 */
#ifdef HAVE_LIBGPM
#include <gpm.h>
#endif

#include "gpm-xterm.h"
#define RELEASE "1.13"

/* JD patch 11/08/1998 */
#define MAXNBPREVCHAR 4		/* I don't think more is usefull, JD */
/******* This from liblow.c(libgpm) */

int JDgpm_flag=0, JDgpm_tried=0, JDgpm_fd=-1, JDgpm_hflag=0;
int JDgpm_zerobased=0, JDgpm_visiblepointer=0, JDgpm_morekeys=0;
struct timeval JDgpm_timeout={10,0};

JDGpm_Handler *JDgpm_handler=NULL;
void *JDgpm_data=NULL;

static int JDgpm_convert_event(char *mdata, Gpm_Event *ePtr);

/******* This from libcurses.c(libgpm) */
#ifdef JDISDEB
int JDGpm_Wgetch(WINDOW *win)
{
int flag, result;
int fd=STDIN_FILENO;
static Gpm_Event ev;
static struct timeval to={0,0} /* JDJDJDJD , tv1={0,0}, tv2 */;
static fd_set selSet;
/* JD patch 11/08/1998 */
static int nbprevchar=0, /* JDJDJD clicks=0,*/ prevchar[MAXNBPREVCHAR];
static char mdata[4]; int c;

#define GET(win) ((win) ? wgetch(win) : getch())

#define GET_TIME(tv) (gettimeofday(&tv, (struct timezone *)NULL))
#define DIF_TIME(t1,t2) ((t2.tv_sec -t1.tv_sec) *1000+ \
                         (t2.tv_usec-t1.tv_usec)/1000)

  if (!JDgpm_flag) return GET(win);
  if (JDgpm_morekeys && JDgpm_handler)
    return (*JDgpm_handler)(&ev,JDgpm_data);

  JDgpm_hflag=0; /* not generated by handler (default) */

/* JD patch 11/08/1998 */
  if (nbprevchar)  /* if ungetc() didn't suffice... */
	return prevchar[--nbprevchar];

  while(1)
    {
    do
      {
      FD_ZERO(&selSet); FD_SET(fd,&selSet);
      JDgpm_timeout.tv_sec=SELECT_TIME;
      flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to);
      }
    while (!flag);
    
    if ((c=GET(win))!=0x1b) return c;
    
    /* escape: go on */
    FD_ZERO(&selSet); FD_SET(fd,&selSet);
    if ((flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to))==0)
      return c;
    if ((c=GET(win))!='[')
      {prevchar[nbprevchar++]=c; return 0x1B;}	/* patche par JD 11/08/1998 */
    
    /* '[': go on */
    FD_ZERO(&selSet); FD_SET(fd,&selSet);
    if ((flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to))==0)
      {prevchar[nbprevchar++]=c; return 0x1B;}	/* patche par JD 11/08/1998 */
    if ((c=GET(win))!='M')
/* patche par JD 11/08/1998 NOTICE: prevchar is a lifo !*/
      {prevchar[nbprevchar++]=c; prevchar[nbprevchar++]='['; return 0x1B;}
    
    /* now, it surely is a mouse event */
      for (c=0;c<3;c++) mdata[c]=GET(win);
      JDgpm_convert_event(mdata,&ev);

      if (JDgpm_handler && (result=(*JDgpm_handler)(&ev,JDgpm_data)))
	{
	JDgpm_hflag=1;
	return result;
	}
      } /* while(1) */
}
#endif

/******* This from liblow.c(libgpm) */
int JDGpm_Open(JDGpm_Connect *conn, int flag)
{
char *tty;
/* JDJDJDJDJD int i; */

  if ((tty=(char *)getenv("TERM")) && !strncmp(tty,"xterm",5))
    {
    if (JDgpm_tried) return JDgpm_fd; /* already open */
    JDgpm_fd=-2;
    GPM_XTERM_ON;
    JDgpm_flag=1;
    return JDgpm_fd;
    }
  return -1;
}

int JDGpm_Close(void)
{
  if (JDgpm_fd==-2) /* xterm */
    GPM_XTERM_OFF;
  JDgpm_tried=0;
  JDgpm_fd=-1;
  return 0;
}

int JDGpm_Getc(FILE *f)
{
#define DELAY_MS 500 /* stolen form mc */
int flag, result;
static Gpm_Event ev;
int fd=fileno(f);
static int count;
static struct timeval to={0,DELAY_MS*1000} /* JDJDJDJDJD , tv1={0,0}, tv2 */ ;
static fd_set selSet;
/* patche par JD 11/08/1998 */
static int nbprevchar=0, /* JDJDJDJDJD clicks=0, */ prevchar[MAXNBPREVCHAR];
static char mdata[4]; int c;

  /* Hmm... I must be sure it is unbuffered */
  if (!(count++))
    setvbuf(f,NULL,_IONBF,0);

  if (!JDgpm_flag) return fgetc(f);

  /* If the handler asked to provide more keys, give them back */
  if (JDgpm_morekeys && JDgpm_handler) return (*JDgpm_handler)(&ev,JDgpm_data);
  JDgpm_hflag=0;

/* patche par JD 11/08/1998 */
  if (nbprevchar)  /* if ungetc() didn't suffice... */
	return prevchar[--nbprevchar];

  while(1)
    {
    do
      {
      FD_ZERO(&selSet); FD_SET(fd,&selSet);
      JDgpm_timeout.tv_sec=SELECT_TIME;
      flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to);
      }
    while (!flag);

    if ((c=fgetc(f))!=0x1b) return c;
    
    /* escape: go on */
    FD_ZERO(&selSet); FD_SET(fd,&selSet);  to.tv_usec=DELAY_MS*1000;
    if ((flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to))==0)
      return c;
    if ((c=fgetc(f))!='[')
/* patche par JD 11/08/1998 */
	{prevchar[nbprevchar++]=c; return 0x1B;}
/*      {ungetc(c,stdin); return 0x1B;} */
    
    /* '[': go on */
      FD_ZERO(&selSet); FD_SET(fd,&selSet);  to.tv_usec=DELAY_MS*1000;
      if ((flag=select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to))==0)
/* patche par JD 11/08/1998 */
	{prevchar[nbprevchar++]=c; return 0x1B;}
/*	{ungetc(c,f); return 0x1B;}	*/
      if ((c=fgetc(f))!='M')
/* patche par JD 11/08/1998 NOTICE: prevchar is a lifo !*/
	{prevchar[nbprevchar++]=c; prevchar[nbprevchar++]='['; return 0x1B;}
      
      /* now, it surely is a mouse event */
      for (c=0;c<3;c++) mdata[c]=fgetc(f);
      JDgpm_convert_event(mdata,&ev);

      if (JDgpm_handler && (result=(*JDgpm_handler)(&ev,JDgpm_data)))
	{
	JDgpm_hflag=1;
	return result;
	}
      } /* while(1) */
}

int JDGpm_Repeat(int msec)
{
struct timeval to={0,0};
fd_set selSet;
int fd=STDIN_FILENO;

  to.tv_usec=msec*1000;
  FD_ZERO(&selSet);
  FD_SET(fd,&selSet);
  return (select(fd+1,&selSet,(fd_set *)NULL,(fd_set *)NULL,&to)==0);
}

/*-------------------------------------------------------------------*/
/* this is the real protocol conversion */
static int JDgpm_convert_event(char *mdata, Gpm_Event *ePtr)
{
static struct timeval tv1={0,0}, tv2;
static int clicks=0;
int c;

#define GET_TIME(tv) (gettimeofday(&tv, (struct timezone *)NULL))
#define DIF_TIME(t1,t2) ((t2.tv_sec -t1.tv_sec) *1000+ \
                         (t2.tv_usec-t1.tv_usec)/1000)


      /* Variable btn has following meaning: */
      c = mdata[0]-32; /* 0="1-down", 1="2-down", 2="3-down", 3="up" */

      if (c==3)
	{
	ePtr->type = GPM_UP | (GPM_SINGLE<<clicks);
	ePtr->buttons = 0;
	GET_TIME (tv1);
	clicks = 0;
	}
      else
	{
	ePtr->type = GPM_DOWN;
	GET_TIME (tv2);
	if (tv1.tv_sec && (DIF_TIME(tv1,tv2)<250)) /* 250ms for double click */
	  {clicks++; clicks%=3;}
	else clicks = 0;
	
	switch (c)
	  {
	  case 0: ePtr->buttons|=GPM_B_LEFT;   break;
	  case 1: ePtr->buttons|=GPM_B_MIDDLE; break;
	  case 2: ePtr->buttons|=GPM_B_RIGHT;  break;
	  default:    /* Nothing */          break;
	  }
	}
      /* Coordinates are 33-based */
      /* Transform them to 1-based */
      ePtr->x = mdata[1]-32;
      ePtr->y = mdata[2]-32;
      return 0;
}
